<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!-- BEGIN opengraph metadata -->
<meta property="og:title" content="boost.fairness" />
<meta property="og:image" content="https://sernior.github.io/fairness/logo1.png" />
<meta property="og:description" content="A collection of advanced syncronization mechanisms." />
<meta property="og:url" content="https://github.com/Sernior/fairness" />
<!-- END opengraph metadata -->
<!-- BEGIN twitter metadata -->
<meta name="twitter:image:src" content="https://sernior.github.io/fairness/logo1.png" />
<meta name="twitter:title" content="boost.fairness" />
<meta name="twitter:description" content="A collection of advanced syncronization mechanisms." />
<!-- END twitter metadata -->
<title>fairness: Implementation Details</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" type="image/png" href="logo1-favicon.png" style="border-radius: 10%;"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom-alternative.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/Sernior/fairness" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="70" height="70" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo1.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fairness
   &#160;<span id="projectnumber">v1.0.0</span>
   </div>
   <div id="projectbrief">A collection of advanced syncronization mechanisms.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_2implementation-details.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Implementation Details</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#extension-page-navigation">Introduction</a><ul><li class="level2"><a href="#autotoc_md19">spinlock</a></li>
<li class="level2"><a href="#autotoc_md20">mutex</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md21">False Sharing</a><ul><li class="level2"><a href="#autotoc_md22">TATAS</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md23">MCS Lock and Craig Algorithm</a></li>
<li class="level1"><a href="#autotoc_md24">Shared and Recursive Mutex</a></li>
<li class="level1"><a href="#autotoc_md25">Other Components and Future Plans</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="autotoc_md18"></a></p>
<p>A technical overview of the priority mutexes in this library.</p>
<h1><a class="anchor" id="extension-page-navigation"></a>
Introduction</h1>
<p>First I want to explain for the context of this document, the difference within this library of <em>mutex</em> and <em>spinlock</em>. A mutex is different from a spinlock in the sense that they use two different ways of performing the wait;</p>
<h2><a class="anchor" id="autotoc_md19"></a>
spinlock</h2>
<p>A spinlock will <em>spinwait</em> which can be visualized as:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::function&lt;void()&gt; relaxOrYield[] = {pause ,std::this_thread::yield};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T ,<span class="keyword">typename</span> K&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> spin_wait(T&amp; mem, K <span class="keyword">const</span> expected) <span class="keyword">noexcept</span> {</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; <a class="code hl_define" href="config_8hpp.html#a96f170569709c4091e18ea1eb61f292b">BOOST_FAIRNESS_SPINWAIT_SPINS</a>; ++i){</div>
<div class="line">        <span class="keywordflow">if</span> (mem.load(std::memory_order_relaxed) != expected)</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">        relaxOrYield[i &gt;= <a class="code hl_define" href="config_8hpp.html#a77adda31959a3584dc6a50e62d03835e">BOOST_FAIRNESS_SPINWAIT_SPINS_RELAXED</a>]();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aconfig_8hpp_html_a77adda31959a3584dc6a50e62d03835e"><div class="ttname"><a href="config_8hpp.html#a77adda31959a3584dc6a50e62d03835e">BOOST_FAIRNESS_SPINWAIT_SPINS_RELAXED</a></div><div class="ttdeci">#define BOOST_FAIRNESS_SPINWAIT_SPINS_RELAXED</div><div class="ttdoc">The number of relaxed spins during a spin_wait operation.</div><div class="ttdef"><b>Definition</b> config.hpp:58</div></div>
<div class="ttc" id="aconfig_8hpp_html_a96f170569709c4091e18ea1eb61f292b"><div class="ttname"><a href="config_8hpp.html#a96f170569709c4091e18ea1eb61f292b">BOOST_FAIRNESS_SPINWAIT_SPINS</a></div><div class="ttdeci">#define BOOST_FAIRNESS_SPINWAIT_SPINS</div><div class="ttdoc">The total number of spins during a spin_wait operation.</div><div class="ttdef"><b>Definition</b> config.hpp:49</div></div>
</div><!-- fragment --><p>So it will stop the thread execution until the value in memory you are currently looking at will change (or the scheduler takes away the context from the thread).</p>
<dl class="section note"><dt>Note</dt><dd>To understand what <a href="https://developer.arm.com/documentation/dui0801/f/A64-General-Instructions/YIELD">pause</a> does. Each architecture has an intruction like this one.</dd></dl>
<h2><a class="anchor" id="autotoc_md20"></a>
mutex</h2>
<p>While instead a mutex`s wait:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> K&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> wait(T&amp; mem, K <span class="keyword">const</span> expected) <span class="keyword">noexcept</span> {</div>
<div class="line">    <span class="keyword">auto</span> memEqualsExpected = [&amp;mem, expected]{</div>
<div class="line">        <span class="keywordflow">return</span> mem.load(std::memory_order_relaxed) == expected;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">do</span> {</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; <a class="code hl_define" href="config_8hpp.html#a9ad7457de04fbbf85165354779e61505">BOOST_FAIRNESS_WAIT_SPINS</a>; ++i){</div>
<div class="line">            <span class="keywordflow">if</span> (!memEqualsExpected())</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">            relaxOrYield[i &gt;= <a class="code hl_define" href="config_8hpp.html#a2e744f49cb92eb5d0cb6aff8dea90862">BOOST_FAIRNESS_WAIT_SPINS_RELAXED</a>]();</div>
<div class="line">        }</div>
<div class="line">        <a class="code hl_function" href="namespaceboost_1_1fairness_1_1detail.html#a031d954c38ec24a05baf1b467611f291">wait_</a>(mem, expected);</div>
<div class="line">    } <span class="keywordflow">while</span> (memEqualsExpected());</div>
<div class="line">}</div>
<div class="ttc" id="aconfig_8hpp_html_a2e744f49cb92eb5d0cb6aff8dea90862"><div class="ttname"><a href="config_8hpp.html#a2e744f49cb92eb5d0cb6aff8dea90862">BOOST_FAIRNESS_WAIT_SPINS_RELAXED</a></div><div class="ttdeci">#define BOOST_FAIRNESS_WAIT_SPINS_RELAXED</div><div class="ttdoc">The total number of spins during a wait operation before a syscall to the OS to yield the cpu through...</div><div class="ttdef"><b>Definition</b> config.hpp:76</div></div>
<div class="ttc" id="aconfig_8hpp_html_a9ad7457de04fbbf85165354779e61505"><div class="ttname"><a href="config_8hpp.html#a9ad7457de04fbbf85165354779e61505">BOOST_FAIRNESS_WAIT_SPINS</a></div><div class="ttdeci">#define BOOST_FAIRNESS_WAIT_SPINS</div><div class="ttdoc">The total number of spins during a wait operation before a syscall to the OS to yield the cpu through...</div><div class="ttdef"><b>Definition</b> config.hpp:67</div></div>
<div class="ttc" id="anamespaceboost_1_1fairness_1_1detail_html_a031d954c38ec24a05baf1b467611f291"><div class="ttname"><a href="namespaceboost_1_1fairness_1_1detail.html#a031d954c38ec24a05baf1b467611f291">boost::fairness::detail::wait_</a></div><div class="ttdeci">void wait_(T &amp;mem, K expected)</div><div class="ttdef"><b>Definition</b> wait_ops_generic.hpp:22</div></div>
</div><!-- fragment --><p>Not only will spin wait for a bit, but after each spin wait will use a syscall (<a href="https://man7.org/linux/man-pages/man2/futex.2.html">FUTEX op WAIT</a> on linux or <a href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitonaddress">waitonaddress</a> on windows) to stop the thread until the memory in that region is different from what we expect. This is also very similar to how the std lib implementators have implemented the <a href="https://en.cppreference.com/w/cpp/atomic/atomic/wait">atomic::wait</a>.</p>
<p>So from now on when I mention a <a class="el" href="classboost_1_1fairness_1_1spinlock__priority__mutex.html" title="The spinlock_priority_mutex is an advanced synchronization mechanism that enhances the traditional mu...">boost::fairness::spinlock_priority_mutex</a> and a <a class="el" href="classboost_1_1fairness_1_1priority__mutex.html" title="The priority_mutex is an advanced synchronization mechanism that enhances the traditional mutex by in...">boost::fairness::priority_mutex</a> the only difference between the two is how they implement the wait operation.</p>
<h1><a class="anchor" id="autotoc_md21"></a>
False Sharing</h1>
<p>The main problem I faced when making this library is finding ways to avoid <a href="https://www.cs.rochester.edu/u/scott/papers/1993_SEDMS_false_sharing.pdf">false sharing</a>.</p>
<p>Let`s imagine of writing a simple spinlock:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>spinlock{</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> lock(){</div>
<div class="line">        <span class="keywordflow">while</span>(locked.test_and_set())</div>
<div class="line">            <span class="keywordflow">continue</span>;</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> unlock(){</div>
<div class="line">        locked.clear();</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    std::atomic_flag locked{};</div>
<div class="line">};</div>
</div><!-- fragment --><p> We can easily see that this solution would suffer from the aforementioned false sharing.</p>
<p>Multiple cores will fetch the memory contained in the locked variable but each time one of them will change its state through <a href="https://en.cppreference.com/w/cpp/atomic/atomic_flag/test_and_set">test_and_set</a> or clear all the other cores will have their local caches invalidated.</p>
<h2><a class="anchor" id="autotoc_md22"></a>
TATAS</h2>
<p>A simple but not scalable improvement to this approach would be to prefetch the data contained in locked and test that before performing the test and set:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>spinlock_tatas{</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> lock(){</div>
<div class="line">        <span class="keywordflow">while</span>(locked.test() &amp;&amp; locked.test_and_set())</div>
<div class="line">            <span class="keywordflow">continue</span>;</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> unlock(){</div>
<div class="line">        locked.clear();</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    std::atomic_flag locked{};</div>
<div class="line">};</div>
</div><!-- fragment --><p> Now we will at least test the memory which is a simple read operation (and wont invalidate caches) before doing the test and set (which instead would invalidate caches).</p>
<p>This approach is known as test and test and set (or TATAS).</p>
<p>Basing a priority mutex on this approach is quite simple and by defining the macro BOOST_FAIRNESS_USE_TATAS_SPINLOCK users of my lib can infact use this approach.</p>
<p>This approach is very fast under low contention as the algorithm itself is quite simple but as stated it does not scale.</p>
<p>A more effective approach to address this problem is to implement a list-based locking mechanism, where each node has its own 'locked' variable. When a thread, currently holding the lock, performs an unlock operation, it sets the 'locked' variable of the next node instead of releasing a global 'locked' variable.</p>
<p>To completely avoid false sharing, nodes should be aligned to 128 bytes. While the majority of modern architectures have cache lines with a size of 64 bytes, the way L2 updates modified cache lines in most modern architectures occurs two at a time, potentially causing delays even among adjacent cache lines.</p>
<p>For instance this is from the optimization manual of my cpu (AMD zen4 microarchitecture):</p>
<p><img src="https://sernior.github.io/fairness/l2fetch.png" alt="" class="readme-img" style="object-fit: cover; object-position: 100% 0; width: 100%;" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md23"></a>
MCS Lock and Craig Algorithm</h1>
<p>A well-known approach in the realm of list-based locks is the <a href="https://www.cs.rochester.edu/u/scott/papers/1991_TOCS_synch.pdf">MCS lock</a>. While the MCS lock is notable for providing mostly FIFO fairness, it doesn't align with the specific requirements for the context of this library.</p>
<p>I aimed for a mutex that operates like to a priority queue rather than a simple queue so that users could define their own fairness policies depending on their needs. Luckly for me the algorithm I was looking for already existed, created in 1993 from Travis S. Craig.</p>
<p>Unfortunately this came with a new set of problems.</p>
<p><a href="https://dada.cs.washington.edu/research/tr/1993/02/UW-CSE-93-02-02.pdf">The Craig algorithm</a> relies on two essential structures: "Thread" and "Request." Efficient allocation, usage, and deallocation of these structures are crucial for the algorithm's performance.</p>
<p>"Thread" structures, representing threads, are relatively straightforward to handle. A simple thread-local pool of "Thread" structures is employed, eliminating the need for concurrency management.</p>
<p>"Request" structures require more careful consideration. To balance efficiency and resource usage, a limited pool of "Request" structures is maintained, and users can control the size using the macro BOOST_FAIRNESS_MAX_PQNODES;</p>
<p>"Request" structures contain the memory used by the lock where to perform wait or spinwait (depending if you are using a priority_mutex or a priority_spinlock) so they are aligned at 128 bytes.</p>
<p>When a thread requests a lock, it must acquire a "Request" to enqueue. Each "Request" includes an additional atomic flag (inUse_) to indicate whether the current request is in use or available.</p>
<div class="fragment"><div class="line">Request* getRequest(){</div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; N; ++i){</div>
<div class="line">        <span class="keywordflow">if</span> (!reqs_[i].inUse_.test(std::memory_order_relaxed) &amp;&amp; !reqs_[i].inUse_.test_and_set(std::memory_order_acquire))</div>
<div class="line">            <span class="keywordflow">return</span> &amp;reqs_[i];</div>
<div class="line">        spin_wait();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The spin policy, defined in the spin_wait() function, helps manage the waiting period during the acquisition of a "Request." </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>(;;){</div>
<div class="line">    req = reqs_.getRequest();</div>
<div class="line">    <span class="keywordflow">if</span> (req != <span class="keyword">nullptr</span>)</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    std::this_thread::yield(); <span class="comment">// there are no free Requests now just yield</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Setting up the spin policies, such as adjusting macros like BOOST_FAIRNESS_GETREQUEST_SPINS and BOOST_FAIRNESS_GETREQUEST_SPINS_RELAXED, is crucial for achieving optimal performance. The default values for these macros have been carefully chosen and are known to perform well across different architectures. However, users are encouraged to run benchmarks and fine-tune these values based on their specific system requirements to further optimize performance.</p>
<h1><a class="anchor" id="autotoc_md24"></a>
Shared and Recursive Mutex</h1>
<p>Complex mutexes, such as shared and recursive mutexes, can be implemented using a priority_spinlock to ensure the atomicity of their methods. This approach not only enables the library to provide maximum fairness but also allows for seamless adaptability to changes in the priority_spinlock implementation. For instance, switching to BOOST_FAIRNESS_USE_TATAS affects all mutexes uniformly as it alters the underlying implementation.</p>
<h1><a class="anchor" id="autotoc_md25"></a>
Other Components and Future Plans</h1>
<p>As of January 21, 2024, this library includes RAII wrappers <a class="el" href="classboost_1_1fairness_1_1unique__lock.html" title="The class unique_lock is a general-purpose mutex ownership wrapper allowing deferred locking,...">boost::fairness::unique_lock</a> and <a class="el" href="classboost_1_1fairness_1_1shared__lock.html" title="The class shared_lock is a general-purpose shared mutex ownership wrapper allowing deferred locking,...">boost::fairness::shared_lock</a>, mirroring the functionality of their std counterparts. Notably, these wrappers accept a priority parameter. Currently, the library lacks priority_convars and lock_guard (low priority). Additionally, more experimentation is required for the requestPool, as there is an ongoing pursuit of improvements in that area. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
