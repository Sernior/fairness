<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!-- BEGIN opengraph metadata -->
<meta property="og:title" content="boost.fairness" />
<meta property="og:image" content="https://sernior.github.io/fairness/logo1.png" />
<meta property="og:description" content="A collection of advanced syncronization mechanisms." />
<meta property="og:url" content="https://github.com/Sernior/fairness" />
<!-- END opengraph metadata -->
<!-- BEGIN twitter metadata -->
<meta name="twitter:image:src" content="https://sernior.github.io/fairness/logo1.png" />
<meta name="twitter:title" content="boost.fairness" />
<meta name="twitter:description" content="A collection of advanced syncronization mechanisms." />
<!-- END twitter metadata -->
<title>fairness: boost::fairness::shared_priority_mutex&lt; N &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" type="image/png" href="logo1-favicon.png" style="border-radius: 10%;"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom-alternative.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/Sernior/fairness" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="70" height="70" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo1.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fairness
   &#160;<span id="projectnumber">v0.1</span>
   </div>
   <div id="projectbrief">A collection of advanced syncronization mechanisms.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classboost_1_1fairness_1_1shared__priority__mutex.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classboost_1_1fairness_1_1shared__priority__mutex-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">boost::fairness::shared_priority_mutex&lt; N &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a> is an advanced synchronization mechanism that enhances the traditional shared_mutex by introducing a priority-based approach. <br  />
 The <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a> class is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads. In contrast to other mutex types which facilitate exclusive access, a shared_mutex has two levels of access:  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="shared__priority__mutex_8hpp_source.html">shared_priority_mutex.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0fd7fd33d4c3ecaaeebdcb815f5b855c" id="r_a0fd7fd33d4c3ecaaeebdcb815f5b855c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fd7fd33d4c3ecaaeebdcb815f5b855c">lock</a> (<a class="el" href="namespaceboost_1_1fairness.html#ae7e29511af6c21c2c41f9dc351e2d969">Priority_t</a> const priority=0)</td></tr>
<tr class="memdesc:a0fd7fd33d4c3ecaaeebdcb815f5b855c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to acquire the unique ownership of the <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a>, blocking the thread if the <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a> was already owned or other threads are waiting with higher priority. <br  />
 If another thread is holding an exclusive <a class="el" href="#a0fd7fd33d4c3ecaaeebdcb815f5b855c" title="Try to acquire the unique ownership of the shared_priority_mutex, blocking the thread if the shared_p...">lock()</a> or a shared_lock() on the same <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a> the a call to lock will block execution until all such locks are released. While <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a> is locked in an exclusive mode, no other <a class="el" href="#a0fd7fd33d4c3ecaaeebdcb815f5b855c" title="Try to acquire the unique ownership of the shared_priority_mutex, blocking the thread if the shared_p...">lock()</a> of any kind can also be held. <br  />
 If lock is called by a thread that already owns the shared_mutex in any mode (exclusive or shared), the behavior is undefined. A prior <a class="el" href="#a680aae71007cd265e19c2e6b7288579f" title="Release the shared_priority_mutex from unique ownership.   The mutex must be locked by the current th...">unlock()</a> operation on the same mutex <em>synchronizes-with</em> (as defined in <a href="https://en.cppreference.com/w/cpp/atomic/memory_order">std::memory_order</a>) this operation.  <br /></td></tr>
<tr class="separator:a0fd7fd33d4c3ecaaeebdcb815f5b855c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d900b0a0718756f737d7ed7a66567b" id="r_a68d900b0a0718756f737d7ed7a66567b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68d900b0a0718756f737d7ed7a66567b">lock_shared</a> (<a class="el" href="namespaceboost_1_1fairness.html#ae7e29511af6c21c2c41f9dc351e2d969">Priority_t</a> priority=0)</td></tr>
<tr class="memdesc:a68d900b0a0718756f737d7ed7a66567b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to acquire the shared ownership of the <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a>, blocking the thread if the <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a> was already uniquely owned or if another thread is waiting for unique ownership with higher priority. <br  />
 If another thread is holding the mutex in exclusive ownership, a call to lock_shared will block execution until shared ownership can be acquired. <br  />
If <a class="el" href="#a68d900b0a0718756f737d7ed7a66567b" title="Try to acquire the shared ownership of the shared_priority_mutex, blocking the thread if the shared_p...">lock_shared()</a> is called by a thread that already owns the mutex in any mode (exclusive or shared), the behavior is undefined. <br  />
 If more than the implementation-defined maximum number of shared owners already locked the mutex in shared mode, lock_shared blocks execution until the number of shared owners is reduced. The maximum number of owners is guaranteed to be at least 10000. <br  />
 A prior <a class="el" href="#a680aae71007cd265e19c2e6b7288579f" title="Release the shared_priority_mutex from unique ownership.   The mutex must be locked by the current th...">unlock()</a> operation on the same mutex <em>synchronizes-with</em> (as defined in <a href="https://en.cppreference.com/w/cpp/atomic/memory_order">std::memory_order</a>) this operation.  <br /></td></tr>
<tr class="separator:a68d900b0a0718756f737d7ed7a66567b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab230ae362ee3b0f6bd3ef4eb320f9b65" id="r_ab230ae362ee3b0f6bd3ef4eb320f9b65"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab230ae362ee3b0f6bd3ef4eb320f9b65">try_lock</a> (<a class="el" href="namespaceboost_1_1fairness.html#ae7e29511af6c21c2c41f9dc351e2d969">Priority_t</a> const priority=0)</td></tr>
<tr class="memdesc:ab230ae362ee3b0f6bd3ef4eb320f9b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to acquire the unique ownership of the <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a>, if successful will return <code>true</code>, <code>false</code> otherwise. <br  />
 This function is allowed to fail spuriously and return <code>false</code> even if the mutex is not currently locked by any other thread. <br  />
 If <a class="el" href="#ab230ae362ee3b0f6bd3ef4eb320f9b65" title="Try to acquire the unique ownership of the shared_priority_mutex, if successful will return true,...">try_lock()</a> is called by a thread that already owns the <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a> in any mode (shared or exclusive), the behavior is undefined. <br  />
 Prior <a class="el" href="#a680aae71007cd265e19c2e6b7288579f" title="Release the shared_priority_mutex from unique ownership.   The mutex must be locked by the current th...">unlock()</a> operation on the same mutex <em>synchronizes-with</em> (as defined in <a href="https://en.cppreference.com/w/cpp/atomic/memory_order">std::memory_order</a>) this operation if it returns <code>true</code>. Note that prior <a class="el" href="#a0fd7fd33d4c3ecaaeebdcb815f5b855c" title="Try to acquire the unique ownership of the shared_priority_mutex, blocking the thread if the shared_p...">lock()</a> does not synchronize with this operation if it returns <code>false</code>.  <br /></td></tr>
<tr class="separator:ab230ae362ee3b0f6bd3ef4eb320f9b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae253b03d65922a41dec258b7121104d4" id="r_ae253b03d65922a41dec258b7121104d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae253b03d65922a41dec258b7121104d4">try_lock_shared</a> (<a class="el" href="namespaceboost_1_1fairness.html#ae7e29511af6c21c2c41f9dc351e2d969">Priority_t</a> priority=0)</td></tr>
<tr class="memdesc:ae253b03d65922a41dec258b7121104d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to acquire the shared ownership of the <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a>, if successful will return <code>true</code>, <code>false</code> otherwise. <br  />
 This function is allowed to fail spuriously and return <code>false</code> even if the mutex is not currenly exclusively locked by any other thread. <br  />
 A prior <a class="el" href="#a680aae71007cd265e19c2e6b7288579f" title="Release the shared_priority_mutex from unique ownership.   The mutex must be locked by the current th...">unlock()</a> operation on the same mutex <em>synchronizes-with</em> (as defined in <a href="https://en.cppreference.com/w/cpp/atomic/memory_order">std::memory_order</a>) this operation if it returns <code>true</code>. <br  />
 The behavior is undefined if the calling thread already owns the mutex in any mode.  <br /></td></tr>
<tr class="separator:ae253b03d65922a41dec258b7121104d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680aae71007cd265e19c2e6b7288579f" id="r_a680aae71007cd265e19c2e6b7288579f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a680aae71007cd265e19c2e6b7288579f">unlock</a> ()</td></tr>
<tr class="memdesc:a680aae71007cd265e19c2e6b7288579f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a> from unique ownership. <br  />
 The mutex must be locked by the current thread of execution, otherwise, the behavior is undefined. <br  />
 This operation <em>synchronizes-with</em> (as defined in <a href="https://en.cppreference.com/w/cpp/atomic/memory_order">std::memory_order</a>) any subsequent lock operation that obtains ownership of the same mutex.  <br /></td></tr>
<tr class="separator:a680aae71007cd265e19c2e6b7288579f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64efe5d5709af228afe007066196654" id="r_af64efe5d5709af228afe007066196654"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af64efe5d5709af228afe007066196654">unlock_shared</a> ()</td></tr>
<tr class="memdesc:af64efe5d5709af228afe007066196654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a> from shared ownership by the calling thread. <br  />
The mutex <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a> be locked by the current thread of execution in shared mode, otherwise, the behavior is undefined. <br  />
 This operation <em>synchronizes-with</em> (as defined in <a href="https://en.cppreference.com/w/cpp/atomic/memory_order">std::memory_order</a>) any subsequent <a class="el" href="#a0fd7fd33d4c3ecaaeebdcb815f5b855c" title="Try to acquire the unique ownership of the shared_priority_mutex, blocking the thread if the shared_p...">lock()</a> operation that obtains ownership of the same <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a>.  <br /></td></tr>
<tr class="separator:af64efe5d5709af228afe007066196654"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;size_t N = 1&gt;<br />
requires (N &gt;= 1 &amp;&amp; N &lt;= <a class="el" href="priority__t_8hpp.html#ab63ed35d4aa8f18cc832fecbf13ba0ae">BOOST_FAIRNESS_MAXIMUM_PRIORITY</a>)<br />
class boost::fairness::shared_priority_mutex&lt; N &gt;</div><p>The <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a> is an advanced synchronization mechanism that enhances the traditional shared_mutex by introducing a priority-based approach. <br  />
 The <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a> class is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads. In contrast to other mutex types which facilitate exclusive access, a shared_mutex has two levels of access: </p>
<ul>
<li><em>shared</em> - several threads can share ownership of the same mutex;</li>
<li><em>exclusive</em> - only one thread can own the mutex.</li>
</ul>
<p>If one thread has acquired the <em>exclusive</em> lock (through <a class="el" href="#a0fd7fd33d4c3ecaaeebdcb815f5b855c" title="Try to acquire the unique ownership of the shared_priority_mutex, blocking the thread if the shared_p...">lock()</a>, <a class="el" href="#ab230ae362ee3b0f6bd3ef4eb320f9b65" title="Try to acquire the unique ownership of the shared_priority_mutex, if successful will return true,...">try_lock()</a>), no other threads can acquire the lock (including the <em>shared</em>). <br  />
 If one thread has acquired the <em>shared</em> lock (through <a class="el" href="#a68d900b0a0718756f737d7ed7a66567b" title="Try to acquire the shared ownership of the shared_priority_mutex, blocking the thread if the shared_p...">lock_shared()</a>, <a class="el" href="#ae253b03d65922a41dec258b7121104d4" title="Try to acquire the shared ownership of the shared_priority_mutex, if successful will return true,...">try_lock_shared()</a>), no other thread can acquire the <em>exclusive</em> lock, but can acquire the <em>shared</em> lock. <br  />
 Only when the <em>exclusive</em> lock has not been acquired by any thread, the <em>shared</em> lock can be acquired by multiple threads. <br  />
Within one thread, only one lock (<em>shared</em> or <em>exclusive</em>) can be acquired at the same time. <br  />
Shared mutexes are especially useful when shared data can be safely read by any number of threads simultaneously, but a thread may only write the same data when no other thread is reading or writing at the same time. <br  />
 The <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a> class satisfies all requirements of <a href="https://en.cppreference.com/w/cpp/named_req/SharedMutex">SharedMutex</a> and <a href="https://en.cppreference.com/w/cpp/named_req/StandardLayoutType">StandardLayoutType</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>: number of 0 indexed priorities the <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a> manages, up to <a href="https://sernior.github.io/fairness/priority__t_8hpp.html#ab63ed35d4aa8f18cc832fecbf13ba0ae">BOOST_FAIRNESS_MAXIMUM_PRIORITY</a>. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a0fd7fd33d4c3ecaaeebdcb815f5b855c" name="a0fd7fd33d4c3ecaaeebdcb815f5b855c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd7fd33d4c3ecaaeebdcb815f5b855c">&#9670;&#160;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html">boost::fairness::shared_priority_mutex</a>&lt; N &gt;::lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1fairness.html#ae7e29511af6c21c2c41f9dc351e2d969">Priority_t</a> const&#160;</td>
          <td class="paramname"><em>priority</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to acquire the unique ownership of the <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a>, blocking the thread if the <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a> was already owned or other threads are waiting with higher priority. <br  />
 If another thread is holding an exclusive <a class="el" href="#a0fd7fd33d4c3ecaaeebdcb815f5b855c" title="Try to acquire the unique ownership of the shared_priority_mutex, blocking the thread if the shared_p...">lock()</a> or a shared_lock() on the same <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a> the a call to lock will block execution until all such locks are released. While <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a> is locked in an exclusive mode, no other <a class="el" href="#a0fd7fd33d4c3ecaaeebdcb815f5b855c" title="Try to acquire the unique ownership of the shared_priority_mutex, blocking the thread if the shared_p...">lock()</a> of any kind can also be held. <br  />
 If lock is called by a thread that already owns the shared_mutex in any mode (exclusive or shared), the behavior is undefined. A prior <a class="el" href="#a680aae71007cd265e19c2e6b7288579f" title="Release the shared_priority_mutex from unique ownership.   The mutex must be locked by the current th...">unlock()</a> operation on the same mutex <em>synchronizes-with</em> (as defined in <a href="https://en.cppreference.com/w/cpp/atomic/memory_order">std::memory_order</a>) this operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td>used to set a priority for this thread to aquire the lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::system_error</td><td>: Throws std::system_error when errors occur, including errors from the underlying operating system that would prevent lock from meeting its specifications. The mutex is not locked in the case of any exception being thrown. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="#a0fd7fd33d4c3ecaaeebdcb815f5b855c" title="Try to acquire the unique ownership of the shared_priority_mutex, blocking the thread if the shared_p...">lock()</a> is usually not called directly: <a class="el" href="classboost_1_1fairness_1_1unique__lock.html" title="The class unique_lock is a general-purpose mutex ownership wrapper allowing deferred locking,...">unique_lock</a>, scoped_lock, and lock_guard are used to manage exclusive locking.</dd></dl>
<h3><a class="anchor" id="autotoc_md3"></a>
Example</h3>
<div class="fragment"><div class="line"><a class="code hl_class" href="classboost_1_1fairness_1_1shared__priority__mutex.html">shared_priority_mutex&lt;10&gt;</a> m;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> my_function(<span class="keywordtype">int</span> prio) {</div>
<div class="line">     <span class="comment">//...some code.</span></div>
<div class="line">     m.lock(prio);</div>
<div class="line">     <span class="comment">//...some code.</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassboost_1_1fairness_1_1shared__priority__mutex_html"><div class="ttname"><a href="classboost_1_1fairness_1_1shared__priority__mutex.html">boost::fairness::shared_priority_mutex</a></div><div class="ttdoc">The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...</div><div class="ttdef"><b>Definition</b> shared_priority_mutex.hpp:45</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a68d900b0a0718756f737d7ed7a66567b" name="a68d900b0a0718756f737d7ed7a66567b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d900b0a0718756f737d7ed7a66567b">&#9670;&#160;</a></span>lock_shared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html">boost::fairness::shared_priority_mutex</a>&lt; N &gt;::lock_shared </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1fairness.html#ae7e29511af6c21c2c41f9dc351e2d969">Priority_t</a>&#160;</td>
          <td class="paramname"><em>priority</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to acquire the shared ownership of the <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a>, blocking the thread if the <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a> was already uniquely owned or if another thread is waiting for unique ownership with higher priority. <br  />
 If another thread is holding the mutex in exclusive ownership, a call to lock_shared will block execution until shared ownership can be acquired. <br  />
If <a class="el" href="#a68d900b0a0718756f737d7ed7a66567b" title="Try to acquire the shared ownership of the shared_priority_mutex, blocking the thread if the shared_p...">lock_shared()</a> is called by a thread that already owns the mutex in any mode (exclusive or shared), the behavior is undefined. <br  />
 If more than the implementation-defined maximum number of shared owners already locked the mutex in shared mode, lock_shared blocks execution until the number of shared owners is reduced. The maximum number of owners is guaranteed to be at least 10000. <br  />
 A prior <a class="el" href="#a680aae71007cd265e19c2e6b7288579f" title="Release the shared_priority_mutex from unique ownership.   The mutex must be locked by the current th...">unlock()</a> operation on the same mutex <em>synchronizes-with</em> (as defined in <a href="https://en.cppreference.com/w/cpp/atomic/memory_order">std::memory_order</a>) this operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td>used to set a priority for this thread to aquire the lock_shared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::system_error</td><td>: Throws [std::system_error](<a href="https://en.cppreference.com/w/cpp/error/system_error">https://en.cppreference.com/w/cpp/error/system_error</a>) when errors occur, including errors from the underlying operating system that would prevent lock from meeting its specifications. The mutex is not locked in the case of any exception being thrown. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="#a68d900b0a0718756f737d7ed7a66567b" title="Try to acquire the shared ownership of the shared_priority_mutex, blocking the thread if the shared_p...">lock_shared()</a> is usually not called directly: <a class="el" href="classboost_1_1fairness_1_1shared__lock.html" title="The class shared_lock is a general-purpose shared mutex ownership wrapper allowing deferred locking,...">shared_lock</a> is used to manage shared locking.</dd></dl>
<h3><a class="anchor" id="autotoc_md6"></a>
Example</h3>
<div class="fragment"><div class="line"><a class="code hl_class" href="classboost_1_1fairness_1_1shared__priority__mutex.html">shared_priority_mutex&lt;10&gt;</a> m;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> my_function(<span class="keywordtype">int</span> prio) {</div>
<div class="line">     <span class="comment">//...some code.</span></div>
<div class="line">     m.lock_shared(prio);</div>
<div class="line">     <span class="comment">//...some code.</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab230ae362ee3b0f6bd3ef4eb320f9b65" name="ab230ae362ee3b0f6bd3ef4eb320f9b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab230ae362ee3b0f6bd3ef4eb320f9b65">&#9670;&#160;</a></span>try_lock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html">boost::fairness::shared_priority_mutex</a>&lt; N &gt;::try_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1fairness.html#ae7e29511af6c21c2c41f9dc351e2d969">Priority_t</a> const&#160;</td>
          <td class="paramname"><em>priority</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to acquire the unique ownership of the <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a>, if successful will return <code>true</code>, <code>false</code> otherwise. <br  />
 This function is allowed to fail spuriously and return <code>false</code> even if the mutex is not currently locked by any other thread. <br  />
 If <a class="el" href="#ab230ae362ee3b0f6bd3ef4eb320f9b65" title="Try to acquire the unique ownership of the shared_priority_mutex, if successful will return true,...">try_lock()</a> is called by a thread that already owns the <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a> in any mode (shared or exclusive), the behavior is undefined. <br  />
 Prior <a class="el" href="#a680aae71007cd265e19c2e6b7288579f" title="Release the shared_priority_mutex from unique ownership.   The mutex must be locked by the current th...">unlock()</a> operation on the same mutex <em>synchronizes-with</em> (as defined in <a href="https://en.cppreference.com/w/cpp/atomic/memory_order">std::memory_order</a>) this operation if it returns <code>true</code>. Note that prior <a class="el" href="#a0fd7fd33d4c3ecaaeebdcb815f5b855c" title="Try to acquire the unique ownership of the shared_priority_mutex, blocking the thread if the shared_p...">lock()</a> does not synchronize with this operation if it returns <code>false</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td>used to set a priority for this thread to aquire the lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> : if the lock was acquired successfully. </dd>
<dd>
<code>false</code> : otherwise. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Throws</td><td>nothing.</td></tr>
  </table>
  </dd>
</dl>
<h3><a class="anchor" id="autotoc_md5"></a>
Example</h3>
<div class="fragment"><div class="line"><a class="code hl_class" href="classboost_1_1fairness_1_1shared__priority__mutex.html">shared_priority_mutex&lt;10&gt;</a> m;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> my_function(<span class="keywordtype">int</span> prio) {</div>
<div class="line">     <span class="comment">//...some code.</span></div>
<div class="line">     m.try_lock(prio);</div>
<div class="line">     <span class="comment">//...some code.</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae253b03d65922a41dec258b7121104d4" name="ae253b03d65922a41dec258b7121104d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae253b03d65922a41dec258b7121104d4">&#9670;&#160;</a></span>try_lock_shared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html">boost::fairness::shared_priority_mutex</a>&lt; N &gt;::try_lock_shared </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1fairness.html#ae7e29511af6c21c2c41f9dc351e2d969">Priority_t</a>&#160;</td>
          <td class="paramname"><em>priority</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to acquire the shared ownership of the <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a>, if successful will return <code>true</code>, <code>false</code> otherwise. <br  />
 This function is allowed to fail spuriously and return <code>false</code> even if the mutex is not currenly exclusively locked by any other thread. <br  />
 A prior <a class="el" href="#a680aae71007cd265e19c2e6b7288579f" title="Release the shared_priority_mutex from unique ownership.   The mutex must be locked by the current th...">unlock()</a> operation on the same mutex <em>synchronizes-with</em> (as defined in <a href="https://en.cppreference.com/w/cpp/atomic/memory_order">std::memory_order</a>) this operation if it returns <code>true</code>. <br  />
 The behavior is undefined if the calling thread already owns the mutex in any mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td>used to set a priority for this thread to aquire the lock_shared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> : if the lock was acquired successfully. </dd>
<dd>
<code>false</code> : otherwise. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Throws</td><td>nothing.</td></tr>
  </table>
  </dd>
</dl>
<h3><a class="anchor" id="autotoc_md8"></a>
Example</h3>
<div class="fragment"><div class="line"><a class="code hl_class" href="classboost_1_1fairness_1_1shared__priority__mutex.html">shared_priority_mutex&lt;10&gt;</a> m;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> my_function(<span class="keywordtype">int</span> prio) {</div>
<div class="line">     <span class="comment">//...some code.</span></div>
<div class="line">     m.try_lock_shared(prio);</div>
<div class="line">     <span class="comment">//...some code.</span></div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a id="a680aae71007cd265e19c2e6b7288579f" name="a680aae71007cd265e19c2e6b7288579f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680aae71007cd265e19c2e6b7288579f">&#9670;&#160;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html">boost::fairness::shared_priority_mutex</a>&lt; N &gt;::unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release the <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a> from unique ownership. <br  />
 The mutex must be locked by the current thread of execution, otherwise, the behavior is undefined. <br  />
 This operation <em>synchronizes-with</em> (as defined in <a href="https://en.cppreference.com/w/cpp/atomic/memory_order">std::memory_order</a>) any subsequent lock operation that obtains ownership of the same mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="#a680aae71007cd265e19c2e6b7288579f" title="Release the shared_priority_mutex from unique ownership.   The mutex must be locked by the current th...">unlock()</a> is usually not called directly: <a class="el" href="classboost_1_1fairness_1_1unique__lock.html" title="The class unique_lock is a general-purpose mutex ownership wrapper allowing deferred locking,...">unique_lock</a> and lock_guard are used to manage exclusive locking.</dd></dl>
<h3><a class="anchor" id="autotoc_md4"></a>
Example</h3>
<div class="fragment"><div class="line"><a class="code hl_class" href="classboost_1_1fairness_1_1shared__priority__mutex.html">shared_priority_mutex&lt;10&gt;</a> m;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> my_function() {</div>
<div class="line">     <span class="comment">//...some code.</span></div>
<div class="line">     m.unlock();</div>
<div class="line">     <span class="comment">//...some code.</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af64efe5d5709af228afe007066196654" name="af64efe5d5709af228afe007066196654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64efe5d5709af228afe007066196654">&#9670;&#160;</a></span>unlock_shared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html">boost::fairness::shared_priority_mutex</a>&lt; N &gt;::unlock_shared </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release the <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a> from shared ownership by the calling thread. <br  />
The mutex <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a> be locked by the current thread of execution in shared mode, otherwise, the behavior is undefined. <br  />
 This operation <em>synchronizes-with</em> (as defined in <a href="https://en.cppreference.com/w/cpp/atomic/memory_order">std::memory_order</a>) any subsequent <a class="el" href="#a0fd7fd33d4c3ecaaeebdcb815f5b855c" title="Try to acquire the unique ownership of the shared_priority_mutex, blocking the thread if the shared_p...">lock()</a> operation that obtains ownership of the same <a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html" title="The shared_priority_mutex is an advanced synchronization mechanism that enhances the traditional shar...">shared_priority_mutex</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Throws</td><td>nothing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="#af64efe5d5709af228afe007066196654" title="Release the shared_priority_mutex from shared ownership by the calling thread.  The mutex shared_prio...">unlock_shared()</a> is usually not called directly: <a class="el" href="classboost_1_1fairness_1_1shared__lock.html" title="The class shared_lock is a general-purpose shared mutex ownership wrapper allowing deferred locking,...">shared_lock</a> is used to manage shared locking.</dd></dl>
<h3><a class="anchor" id="autotoc_md7"></a>
Example</h3>
<div class="fragment"><div class="line"><a class="code hl_class" href="classboost_1_1fairness_1_1shared__priority__mutex.html">shared_priority_mutex&lt;10&gt;</a> m;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> my_function() {</div>
<div class="line">     <span class="comment">//...some code.</span></div>
<div class="line">     m.unlock_shared();</div>
<div class="line">     <span class="comment">//...some code.</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/boost/fairness/<a class="el" href="shared__priority__mutex_8hpp_source.html">shared_priority_mutex.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><a class="el" href="namespaceboost_1_1fairness.html">fairness</a></li><li class="navelem"><a class="el" href="classboost_1_1fairness_1_1shared__priority__mutex.html">shared_priority_mutex</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
